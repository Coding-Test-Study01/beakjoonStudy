## [좌표 압축](https://www.acmicpc.net/problem/18870)

### 문제 🤨❔

<pre>
수직선 위에 N개의 좌표 X1, X2, ..., XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.

Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.

X1, X2, ..., XN에 좌표 압축을 적용한 결과 X'1, X'2, ..., X'N를 출력해보자.
</pre>

<br>

### 입력 ↴

<pre>
첫째 줄에 N이 주어진다.

둘째 줄에는 공백 한 칸으로 구분된 X1, X2, ..., XN이 주어진다.
</pre>

<br>

### 출력 ↴

<pre>
첫째 줄에 X'1, X'2, ..., X'N을 공백 한 칸으로 구분해서 출력한다.
</pre>

<br>

### 이지은 솔루션 ❗️ - [시간 : 1836ms]

```js
const fs = require("fs");
const [N, ...XArr] = fs
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split(/\s/)
  .map(Number);

// const XArr = [1000, 999, 1000, 999, 1000, 999]

// 1. XArr 의 중복요소 제거 & 오름차순 정렬 => newXArr 생성
const newXArr = [...new Set(XArr)].sort((a, b) => a - b);

// 2. map 생성
const map = new Map();

// 3. map 에 X 와 해당 인덱스( 좌표 )를 저장
newXArr.forEach((X, i) => {
  map.set(X, i);
});

// 4. map 에서 X 들의 좌표를 get 하여 answer 출력
let answer = "";
XArr.forEach((X, i) => (answer += map.get(X) + " "));
console.log(answer);
```

<br>

### 피드백 💡

<pre>
처음에는 for 문과 findIndex() / indexOf() 로 풀었으나, 시간초과로 통과가 안됨.
시간복잡도 알고리즘에서 findIndex() / indexOf() 은 O(n) 에 속하므로,
더 빠른 O(1) 방법 ( map & set ) 으로 바꿔야했다.

for, forEach 문이 무조건 O(n) 이라고 생각했는데 그건 아닌듯.
시간복잡도 알고리즘은 정확히 이해하지 못했지만,
특정 상황에서 더 빠르게 동작하는 메소드를 아는 게 관건인 것 같다. 

* 배열 메소드 => O(n) 
* map & set => O(1)
</pre>

<br>

### 참고링크 🔗

[좌표압축](https://jeong-jun.su/boj18870/)
[시간복잡도 알고리즘](https://www.notion.so/3bd763ff12a8441cae01ae0506670604)
[풀이 참고](https://sosocodingday.tistory.com/327)
[Map & Set 소개](https://snupi.tistory.com/209))
