## [소수](https://www.acmicpc.net/problem/2581)

### 문제 🤨❔

<pre>
자연수 M과 N이 주어질 때 M이상 N이하의 자연수 중 소수인 것을 모두 골라 이들 소수의 합과 최솟값을 찾는 프로그램을 작성하시오.

예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중 소수는 61, 67, 71, 73, 79, 83, 89, 97 총 8개가 있으므로, 이들 소수의 합은 620이고, 최솟값은 61이 된다.
</pre>

<br>

### 입력 ↴

<pre>
입력의 첫째 줄에 M이, 둘째 줄에 N이 주어진다.

M과 N은 10,000이하의 자연수이며, M은 N보다 작거나 같다.
</pre>

<br>

### 출력 ↴

<pre>
M이상 N이하의 자연수 중 소수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다. 

단, M이상 N이하의 자연수 중 소수가 없을 경우는 첫째 줄에 -1을 출력한다.
</pre>

<br>

### 이지은 솔루션 ❗️ - [시간 : 216ms]

```js
const fs = require("fs");
const [M, N] = fs
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split("\n")
  .map(Number);

// const M = 0
// const N = 1
// C = 현재 순회하는 값

// 1. 소수를 담는 decimalArr 생성
// * 주의: 반복문에서 소수 2 를 누락하기 때문에 조건을 따로 넣어줌.
const decimalArr = M <= 2 && N >= 2 ? [2] : [];

// 2. M<=C<=N 까지 반복문을 돌림
// 3. 현재 순회하는 값 C 를 i 로 [2 ~ (C-1) 까지] 나누며 소수를 decimalArr 에 담는다.
for (let C = M; C <= N; C++) {
  for (let i = 2; i < C; i++) {
    if (!(C % i)) break;
    if (i === C - 1) decimalArr.push(C);
  }
}

// 4. answer 출력
// 4-1. M ~ N 사이에 소수가 있다면, 소수의 합과 소수의 최솟값을 출력
// 4-2. M ~ N 사이에 소수가 없다면, -1 출력
if (decimalArr.length) {
  const decimalSum = decimalArr.reduce((pre, cur) => pre + cur, 0);
  const decimalMin = decimalArr[0];
  console.log(decimalSum);
  console.log(decimalMin);
} else {
  console.log(-1);
}
```
